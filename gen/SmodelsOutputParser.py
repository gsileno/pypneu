# Generated from /home/giovanni/PycharmProjects/pylppn/grammars/SmodelsOutput.g4 by ANTLR 4.6
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"\31q\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write(u"\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\3")
        buf.write(u"\2\5\2\34\n\2\3\2\3\2\3\3\3\3\5\3\"\n\3\3\4\3\4\3\4\3")
        buf.write(u"\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3")
        buf.write(u"\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3")
        buf.write(u"\4\3\4\3\4\3\4\3\4\3\5\6\5G\n\5\r\5\16\5H\3\6\3\6\3\6")
        buf.write(u"\3\6\3\6\3\6\3\6\3\7\3\7\5\7T\n\7\3\b\5\bW\n\b\3\b\3")
        buf.write(u"\b\3\t\3\t\3\t\3\t\3\t\5\t`\n\t\3\n\3\n\3\n\5\ne\n\n")
        buf.write(u"\3\n\3\n\5\ni\n\n\3\13\3\13\3\f\3\f\3\r\3\r\3\r\2\2\16")
        buf.write(u"\2\4\6\b\n\f\16\20\22\24\26\30\2\2m\2\33\3\2\2\2\4\37")
        buf.write(u"\3\2\2\2\6#\3\2\2\2\bF\3\2\2\2\nJ\3\2\2\2\fQ\3\2\2\2")
        buf.write(u"\16V\3\2\2\2\20Z\3\2\2\2\22d\3\2\2\2\24j\3\2\2\2\26l")
        buf.write(u"\3\2\2\2\30n\3\2\2\2\32\34\5\4\3\2\33\32\3\2\2\2\33\34")
        buf.write(u"\3\2\2\2\34\35\3\2\2\2\35\36\7\2\2\3\36\3\3\2\2\2\37")
        buf.write(u"!\5\6\4\2 \"\5\4\3\2! \3\2\2\2!\"\3\2\2\2\"\5\3\2\2\2")
        buf.write(u"#$\7\5\2\2$%\5\b\5\2%&\7\b\2\2&\'\7\t\2\2\'(\7\3\2\2")
        buf.write(u"()\7\27\2\2)*\7\n\2\2*+\7\3\2\2+,\7\26\2\2,-\7\13\2\2")
        buf.write(u"-.\7\3\2\2./\7\26\2\2/\60\7\f\2\2\60\61\7\3\2\2\61\62")
        buf.write(u"\7\26\2\2\62\63\7\r\2\2\63\64\7\3\2\2\64\65\7\26\2\2")
        buf.write(u"\65\66\7\16\2\2\66\67\7\3\2\2\678\7\26\2\289\7\17\2\2")
        buf.write(u"9:\7\3\2\2:;\7\26\2\2;<\7\20\2\2<=\7\3\2\2=>\7\26\2\2")
        buf.write(u">?\7\21\2\2?@\7\3\2\2@A\7\26\2\2AB\7\4\2\2BC\7\26\2\2")
        buf.write(u"CD\7\25\2\2D\7\3\2\2\2EG\5\n\6\2FE\3\2\2\2GH\3\2\2\2")
        buf.write(u"HF\3\2\2\2HI\3\2\2\2I\t\3\2\2\2JK\7\6\2\2KL\7\3\2\2L")
        buf.write(u"M\7\26\2\2MN\7\7\2\2NO\7\3\2\2OP\5\f\7\2P\13\3\2\2\2")
        buf.write(u"QS\5\16\b\2RT\5\f\7\2SR\3\2\2\2ST\3\2\2\2T\r\3\2\2\2")
        buf.write(u"UW\7\22\2\2VU\3\2\2\2VW\3\2\2\2WX\3\2\2\2XY\5\20\t\2")
        buf.write(u"Y\17\3\2\2\2Z_\5\24\13\2[\\\7\24\2\2\\]\5\22\n\2]^\7")
        buf.write(u"\25\2\2^`\3\2\2\2_[\3\2\2\2_`\3\2\2\2`\21\3\2\2\2ae\5")
        buf.write(u"\26\f\2be\5\30\r\2ce\5\20\t\2da\3\2\2\2db\3\2\2\2dc\3")
        buf.write(u"\2\2\2eh\3\2\2\2fg\7\23\2\2gi\5\22\n\2hf\3\2\2\2hi\3")
        buf.write(u"\2\2\2i\23\3\2\2\2jk\7\30\2\2k\25\3\2\2\2lm\7\30\2\2")
        buf.write(u"m\27\3\2\2\2no\7\26\2\2o\31\3\2\2\2\n\33!HSV_dh")
        return buf.getvalue()


class SmodelsOutputParser ( Parser ):

    grammarFileName = "SmodelsOutput.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"': '", u"' ('", u"'smodels version 2.34. Reading...done'", 
                     u"'Answer'", u"'Stable Model'", u"'False'", u"'Duration'", 
                     u"'Number of choice points'", u"'Number of wrong choices'", 
                     u"'Number of atoms'", u"'Number of rules'", u"'Number of picked atoms'", 
                     u"'Number of forced atoms'", u"'Number of truth assignments'", 
                     u"'Size of searchspace (removed)'", u"'-'", u"','", 
                     u"'('", u"')'" ]

    symbolicNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"SMODELSHEADER", 
                      u"ANSWERHEADER", u"STABELMODELHEADER", u"FALSE", u"DURATION", 
                      u"CHOICEPOINTS", u"WRONGCHOICES", u"ATOMS", u"RULES", 
                      u"PICKEDATOMS", u"FORCEDATOMS", u"TRUTHASSIGNMENTS", 
                      u"SIZESEARCHSPACE", u"MINUS", u"COMMA", u"LPAR", u"RPAR", 
                      u"INTEGER", u"FLOAT", u"IDENTIFIER", u"SPACES" ]

    RULE_program = 0
    RULE_statement_list = 1
    RULE_statement = 2
    RULE_answerset_list = 3
    RULE_answerset = 4
    RULE_fact_list = 5
    RULE_literal = 6
    RULE_pos_literal = 7
    RULE_list_parameters = 8
    RULE_predicate = 9
    RULE_identifier = 10
    RULE_constant = 11

    ruleNames =  [ u"program", u"statement_list", u"statement", u"answerset_list", 
                   u"answerset", u"fact_list", u"literal", u"pos_literal", 
                   u"list_parameters", u"predicate", u"identifier", u"constant" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    SMODELSHEADER=3
    ANSWERHEADER=4
    STABELMODELHEADER=5
    FALSE=6
    DURATION=7
    CHOICEPOINTS=8
    WRONGCHOICES=9
    ATOMS=10
    RULES=11
    PICKEDATOMS=12
    FORCEDATOMS=13
    TRUTHASSIGNMENTS=14
    SIZESEARCHSPACE=15
    MINUS=16
    COMMA=17
    LPAR=18
    RPAR=19
    INTEGER=20
    FLOAT=21
    IDENTIFIER=22
    SPACES=23

    def __init__(self, input):
        super(SmodelsOutputParser, self).__init__(input)
        self.checkVersion("4.6")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.ProgramContext, self).__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SmodelsOutputParser.EOF, 0)

        def statement_list(self):
            return self.getTypedRuleContext(SmodelsOutputParser.Statement_listContext,0)


        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_program

        def enterRule(self, listener):
            if hasattr(listener, "enterProgram"):
                listener.enterProgram(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProgram"):
                listener.exitProgram(self)




    def program(self):

        localctx = SmodelsOutputParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 25
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SmodelsOutputParser.SMODELSHEADER:
                self.state = 24
                self.statement_list()


            self.state = 27
            self.match(SmodelsOutputParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Statement_listContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.Statement_listContext, self).__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(SmodelsOutputParser.StatementContext,0)


        def statement_list(self):
            return self.getTypedRuleContext(SmodelsOutputParser.Statement_listContext,0)


        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_statement_list

        def enterRule(self, listener):
            if hasattr(listener, "enterStatement_list"):
                listener.enterStatement_list(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStatement_list"):
                listener.exitStatement_list(self)




    def statement_list(self):

        localctx = SmodelsOutputParser.Statement_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 29
            self.statement()
            self.state = 31
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SmodelsOutputParser.SMODELSHEADER:
                self.state = 30
                self.statement_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.StatementContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SMODELSHEADER(self):
            return self.getToken(SmodelsOutputParser.SMODELSHEADER, 0)

        def answerset_list(self):
            return self.getTypedRuleContext(SmodelsOutputParser.Answerset_listContext,0)


        def FALSE(self):
            return self.getToken(SmodelsOutputParser.FALSE, 0)

        def DURATION(self):
            return self.getToken(SmodelsOutputParser.DURATION, 0)

        def FLOAT(self):
            return self.getToken(SmodelsOutputParser.FLOAT, 0)

        def CHOICEPOINTS(self):
            return self.getToken(SmodelsOutputParser.CHOICEPOINTS, 0)

        def INTEGER(self, i=None):
            if i is None:
                return self.getTokens(SmodelsOutputParser.INTEGER)
            else:
                return self.getToken(SmodelsOutputParser.INTEGER, i)

        def WRONGCHOICES(self):
            return self.getToken(SmodelsOutputParser.WRONGCHOICES, 0)

        def ATOMS(self):
            return self.getToken(SmodelsOutputParser.ATOMS, 0)

        def RULES(self):
            return self.getToken(SmodelsOutputParser.RULES, 0)

        def PICKEDATOMS(self):
            return self.getToken(SmodelsOutputParser.PICKEDATOMS, 0)

        def FORCEDATOMS(self):
            return self.getToken(SmodelsOutputParser.FORCEDATOMS, 0)

        def TRUTHASSIGNMENTS(self):
            return self.getToken(SmodelsOutputParser.TRUTHASSIGNMENTS, 0)

        def SIZESEARCHSPACE(self):
            return self.getToken(SmodelsOutputParser.SIZESEARCHSPACE, 0)

        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_statement

        def enterRule(self, listener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)




    def statement(self):

        localctx = SmodelsOutputParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 33
            self.match(SmodelsOutputParser.SMODELSHEADER)
            self.state = 34
            self.answerset_list()
            self.state = 35
            self.match(SmodelsOutputParser.FALSE)
            self.state = 36
            self.match(SmodelsOutputParser.DURATION)
            self.state = 37
            self.match(SmodelsOutputParser.T__0)
            self.state = 38
            self.match(SmodelsOutputParser.FLOAT)
            self.state = 39
            self.match(SmodelsOutputParser.CHOICEPOINTS)
            self.state = 40
            self.match(SmodelsOutputParser.T__0)
            self.state = 41
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 42
            self.match(SmodelsOutputParser.WRONGCHOICES)
            self.state = 43
            self.match(SmodelsOutputParser.T__0)
            self.state = 44
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 45
            self.match(SmodelsOutputParser.ATOMS)
            self.state = 46
            self.match(SmodelsOutputParser.T__0)
            self.state = 47
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 48
            self.match(SmodelsOutputParser.RULES)
            self.state = 49
            self.match(SmodelsOutputParser.T__0)
            self.state = 50
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 51
            self.match(SmodelsOutputParser.PICKEDATOMS)
            self.state = 52
            self.match(SmodelsOutputParser.T__0)
            self.state = 53
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 54
            self.match(SmodelsOutputParser.FORCEDATOMS)
            self.state = 55
            self.match(SmodelsOutputParser.T__0)
            self.state = 56
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 57
            self.match(SmodelsOutputParser.TRUTHASSIGNMENTS)
            self.state = 58
            self.match(SmodelsOutputParser.T__0)
            self.state = 59
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 60
            self.match(SmodelsOutputParser.SIZESEARCHSPACE)
            self.state = 61
            self.match(SmodelsOutputParser.T__0)
            self.state = 62
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 63
            self.match(SmodelsOutputParser.T__1)
            self.state = 64
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 65
            self.match(SmodelsOutputParser.RPAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Answerset_listContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.Answerset_listContext, self).__init__(parent, invokingState)
            self.parser = parser

        def answerset(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SmodelsOutputParser.AnswersetContext)
            else:
                return self.getTypedRuleContext(SmodelsOutputParser.AnswersetContext,i)


        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_answerset_list

        def enterRule(self, listener):
            if hasattr(listener, "enterAnswerset_list"):
                listener.enterAnswerset_list(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAnswerset_list"):
                listener.exitAnswerset_list(self)




    def answerset_list(self):

        localctx = SmodelsOutputParser.Answerset_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_answerset_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 67
                self.answerset()
                self.state = 70 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==SmodelsOutputParser.ANSWERHEADER):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnswersetContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.AnswersetContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ANSWERHEADER(self):
            return self.getToken(SmodelsOutputParser.ANSWERHEADER, 0)

        def INTEGER(self):
            return self.getToken(SmodelsOutputParser.INTEGER, 0)

        def STABELMODELHEADER(self):
            return self.getToken(SmodelsOutputParser.STABELMODELHEADER, 0)

        def fact_list(self):
            return self.getTypedRuleContext(SmodelsOutputParser.Fact_listContext,0)


        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_answerset

        def enterRule(self, listener):
            if hasattr(listener, "enterAnswerset"):
                listener.enterAnswerset(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAnswerset"):
                listener.exitAnswerset(self)




    def answerset(self):

        localctx = SmodelsOutputParser.AnswersetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_answerset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.match(SmodelsOutputParser.ANSWERHEADER)
            self.state = 73
            self.match(SmodelsOutputParser.T__0)
            self.state = 74
            self.match(SmodelsOutputParser.INTEGER)
            self.state = 75
            self.match(SmodelsOutputParser.STABELMODELHEADER)
            self.state = 76
            self.match(SmodelsOutputParser.T__0)
            self.state = 77
            self.fact_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fact_listContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.Fact_listContext, self).__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(SmodelsOutputParser.LiteralContext,0)


        def fact_list(self):
            return self.getTypedRuleContext(SmodelsOutputParser.Fact_listContext,0)


        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_fact_list

        def enterRule(self, listener):
            if hasattr(listener, "enterFact_list"):
                listener.enterFact_list(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitFact_list"):
                listener.exitFact_list(self)




    def fact_list(self):

        localctx = SmodelsOutputParser.Fact_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_fact_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.literal()
            self.state = 81
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SmodelsOutputParser.MINUS or _la==SmodelsOutputParser.IDENTIFIER:
                self.state = 80
                self.fact_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.LiteralContext, self).__init__(parent, invokingState)
            self.parser = parser

        def pos_literal(self):
            return self.getTypedRuleContext(SmodelsOutputParser.Pos_literalContext,0)


        def MINUS(self):
            return self.getToken(SmodelsOutputParser.MINUS, 0)

        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_literal

        def enterRule(self, listener):
            if hasattr(listener, "enterLiteral"):
                listener.enterLiteral(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLiteral"):
                listener.exitLiteral(self)




    def literal(self):

        localctx = SmodelsOutputParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SmodelsOutputParser.MINUS:
                self.state = 83
                self.match(SmodelsOutputParser.MINUS)


            self.state = 86
            self.pos_literal()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pos_literalContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.Pos_literalContext, self).__init__(parent, invokingState)
            self.parser = parser

        def predicate(self):
            return self.getTypedRuleContext(SmodelsOutputParser.PredicateContext,0)


        def LPAR(self):
            return self.getToken(SmodelsOutputParser.LPAR, 0)

        def list_parameters(self):
            return self.getTypedRuleContext(SmodelsOutputParser.List_parametersContext,0)


        def RPAR(self):
            return self.getToken(SmodelsOutputParser.RPAR, 0)

        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_pos_literal

        def enterRule(self, listener):
            if hasattr(listener, "enterPos_literal"):
                listener.enterPos_literal(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPos_literal"):
                listener.exitPos_literal(self)




    def pos_literal(self):

        localctx = SmodelsOutputParser.Pos_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_pos_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self.predicate()
            self.state = 93
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SmodelsOutputParser.LPAR:
                self.state = 89
                self.match(SmodelsOutputParser.LPAR)
                self.state = 90
                self.list_parameters()
                self.state = 91
                self.match(SmodelsOutputParser.RPAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class List_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.List_parametersContext, self).__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SmodelsOutputParser.IdentifierContext,0)


        def constant(self):
            return self.getTypedRuleContext(SmodelsOutputParser.ConstantContext,0)


        def pos_literal(self):
            return self.getTypedRuleContext(SmodelsOutputParser.Pos_literalContext,0)


        def COMMA(self):
            return self.getToken(SmodelsOutputParser.COMMA, 0)

        def list_parameters(self):
            return self.getTypedRuleContext(SmodelsOutputParser.List_parametersContext,0)


        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_list_parameters

        def enterRule(self, listener):
            if hasattr(listener, "enterList_parameters"):
                listener.enterList_parameters(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitList_parameters"):
                listener.exitList_parameters(self)




    def list_parameters(self):

        localctx = SmodelsOutputParser.List_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_list_parameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.state = 95
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 96
                self.constant()
                pass

            elif la_ == 3:
                self.state = 97
                self.pos_literal()
                pass


            self.state = 102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SmodelsOutputParser.COMMA:
                self.state = 100
                self.match(SmodelsOutputParser.COMMA)
                self.state = 101
                self.list_parameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.PredicateContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(SmodelsOutputParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_predicate

        def enterRule(self, listener):
            if hasattr(listener, "enterPredicate"):
                listener.enterPredicate(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPredicate"):
                listener.exitPredicate(self)




    def predicate(self):

        localctx = SmodelsOutputParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.match(SmodelsOutputParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.IdentifierContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(SmodelsOutputParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_identifier

        def enterRule(self, listener):
            if hasattr(listener, "enterIdentifier"):
                listener.enterIdentifier(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIdentifier"):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = SmodelsOutputParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.match(SmodelsOutputParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SmodelsOutputParser.ConstantContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(SmodelsOutputParser.INTEGER, 0)

        def getRuleIndex(self):
            return SmodelsOutputParser.RULE_constant

        def enterRule(self, listener):
            if hasattr(listener, "enterConstant"):
                listener.enterConstant(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitConstant"):
                listener.exitConstant(self)




    def constant(self):

        localctx = SmodelsOutputParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 108
            self.match(SmodelsOutputParser.INTEGER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





